=head1 NAME

HTML::Seamstress - HTML::Tree subclass for HTML templating via tree rewriting

=head1 SYNOPSIS

HTML::Seamstress provides "fourth generation" dynamic HTML generation
(templating). 

In the beginning we had...


=head2 First generation dynamic HTML production

First generation dynamic HTML production used server-side
includes:

 <p>Today's date is   <!--#echo var="DATE_LOCAL" --> </p>

=head2 Second generation dynamic HTML production

The next phase of HTML generation saw
embedded HTML snippets in Perl code. For example:

 sub header {
   my $title = shift;
   print <<"EOHEADER";
   <head>
      <title>$title</title>
   </head>
   EOHEADER
 }

=head2 Third generation dynamic HTML production

The 3rd generation solutions embed
programming language constructs with HTML. The language constructs
are either a real language (as is with L<HTML::Mason>) or a
pseudo/mini-language (as is with L<PeTaL>, L<Template> or
L<HTML::Template>). Let's see some L<Template> code:

 <p>Hi there [% name %], are you enjoying your stay?</p>

=head2 Talkin' bout them generations...

Up to now, all approaches to this issue tamper with the
HTML in some form or fashion:

=over 

=item * Generation 1 adds SSI processing instructions

=item * Generation 2 rips the HTML apart and adds programming elements

=item * Generation 3 sprinkles programming constructs in the HTML

=back

=head2 Enter fourth generation dynamic HTML production

The fourth generation of HTML production is distinguished by no need
for tampering with the HTML. There are a wealth of XML-based modules
which provide this approach (L<XML::Twig>, L<XML::LibXML>,
L<XML::TreeBuilder>, L<XML::DOM>). HTML::Seamstress is the one CPAN
module based around HTML and L<HTML::Tree> for this approach.

=head1 PHILOSOPHY and MOTIVATION of HTML::Seamstress

When looking at HTML::Seamstress, we are looking at a uniquely
positioned 4th-generation HTML generator. Seamstress offers two sets
of advantages: those common to all 4th generation htmlgens and those
common to a subclass of L<HTML::Tree>.

=head2 Reap 4th generation dynamic HTML generation benefits

What advantages does this fourth way of HTML manipulation offer? Let's
take a look:

=head3 Separate HTML development and its programmatic modification  

The contents of the document remain legal HTML/XML that can be be
developed using standard interactive design tools. The flow of control
of the code remains separate from the page. Technologies that mix
content and data in a single file result in code that is often
difficult to understand and has trouble taking full advantage of the
object oriented programming paradigm.  


=head3 Reduced learning curve

If you have a strong hold on 
object-oriented Perl and a solid understand of the tree-based nature
of HTML, then all you need to do is read the manual pages showing how
Seamstress and related modules offer tree manipulation routines and
you are done.

Extension just requires writing new Perl methods - a snap for any
object oriented Perler.

=head3 Static validation and formatting

Mixing Perl and HTML (by any of the generation 1-3 approaches)
makes it impossible to use standard validation and formatting tools
for either Perl or HTML.


=head3 Two full-strength programming languages: HTML and Perl

Perl and HTML are solid technologies with years of effort behind
making them robust and flexible enough to meet real-world
technological demands.

=head3 Multiple views and reuses of the same element

Because manipulator and manipulated are separate, we can choose
manipulators and/or stack them at will.


=head2 Reap the benefits of using HTML::Tree

=head3 Pragmatic HTML instead of strict X(HT)ML

The real world is unfortunately more about getting HTML to work with
IE and maybe 1 or 2 other browsers. Strict XHTML may not be acceptable
under time and corporate pressures to get things to work with quirky
browsers. 

=head3 Rich API and User Contributions

L<HTML::Tree> has a nice large set of accessor/modifier functions. If
that is not enough, then take a gander at Matthew Sisk's
contributions: L<http://search.cpan.org/~msisk/> as well as
L<HTML::Element::Library>. 


=head1 USAGE

Now it's time to look at some examples. Before doing so, it is
imperative that you understand the tree structure of HTML.

=head2 Understand that HTML is a tree

The best representation of this fact is this slide right here:

L<http://xmlc.objectweb.org/doc/xmlcSlides/xmlcSlides.html#de>

If you understand this (and maybe the rest of the slides), then you
have a good grip on seeing HTML as a tree.

L<HTML::AboutTrees> does also teach this, but it takes a while before
he gets to what matters to us. It's a fun read nonetheless. 

Now that we've got this concept under our belts let's try some full examples.

=head2 Install and Setup Seamstress

The first thing to remember is that Seamstress is really just
convenience functions for L<HTML::Tree|HTML::Tree>. You can do
entirely without 
Seamstress. It's just that my daily real-world obligations have lead
to a set of library functions (HTML::Element::Library) and a
convenient way to locate "templates" (C<spkg.pl>) that work well on
top of L<HTML::Tree|HTML::Tree>

=over

=item * move spkg.pl and sbase.pl onto your execution C<$PATH>

C<sbase.pl> and C<spkg.pl> are used to simplify the process of 
parsing an HTML file into HTML::Treebuilder object. In other words
instead of having to do this in your Perl programs:

 use HTML::TreeBuilder;

 my $tree = HTML::TreeBuilder->new_from_file('/usr/htdocs/hello.html');

You can do this:

 use htdocs::hello;

 my $tree = htdocs::hello->new;

The lines of code is not much different, but abstracting away absolute
paths is important in production environments where the absolute path 
may come from who knows where via who knows how.

=item * run sbase.pl

sbase.pl will ask you 2 very simple questions. Just answer them. 
When it is finished, it will have installed a package named 
C<HTML::Seamstress::Base> on your C<@INC>. This module contains one
function, C<comp_root()> which points to a place you wouldn't
typically have on your C<@INC> but which you must have because your
HTML file and corresponding C<.pm> abstracting it are going to be
there. 

=item * run spkg.pl

In the default seutp, 
no options need be supplied to this script. They
are useful in cases where you have more than one document root or want
to inherit from more than one place.


 metaperl@pool-71-109-151-76:~/www$ spkg.pl moose.html
 comp_root........ /home/metaperl/
 html_file_path... /home/metaperl/www/
 html_file........ moose.html
 html_file sans... moose
 moose.html compiled to package www::moose

=item * load your abstracted HTML and manipulate it

Now, from Perl, to get the TreeBuilder object
representing this HTML file, we simply do this:

 use www::moose;
 
 my $tree = www::moose->new;
 # manipulate tree...
 $tree->as_HTML;

In a mod_perl setup, you would want to pre-load your HTML and
L<Class::Cache|Class::Cache> was designed for this very purpose. But
that's a topic for another time.

In a setup with HTML files in numerous places, I recommend setting up
multiple C<HTML::Seamstress::Base::here>,
C<HTML::Seamstress::Base::there> for each file root. To do this, you
will need to use the C<--base_pkg> and C<--base_pkg_root> options to
spkg.pl


=item * That's it!

Now you are ready to abstract away as many files as you want with the
same C<spkg.pl> call. Just supply it with a different HTML file to
create a different package. Then C<use> them, C<new> them and
manipulate them and C<< $tree->as_HTML >> them at will.

Now it's time to rock and roll!


=back


=head2 Text substitution == node mutation

In our first example, we want to perform simple text substitution on
the HTML template document:

 <html>
 <head>
   <title>Hello World</title>
 </head>
 <body>
 <h1>Hello World</h1>
   <p>Hello, my name is <span id="name">dummy_name</span>.
   <p>Today's date is <span id="date">dummy_date</span>.
 </body>
 </html>

First save this somewhere on your document root. Then compile it with
C<spkg.pl>. Now you simply use
the "compiled" version of HTML with API calls to 
HTML::TreeBuilder, HTML::Element, and HTML::Element::Library.

 use html::hello_world; 
 
 my $tree = html::hello_world->new; 
 $tree->look_down(id => name)->replace_content('terrence brannon');
 $tree->look_down(id => date)->replace_content('5/11/1969');
 print $tree->as_HTML;

C<replace_content()> is a convenience function in
L<HTML::Element::Library>. 



=head2 If-then-else == node(s) deletion


 <span id="age_dialog">
    <span id="under10">
       Hello, does your mother know you're 
       using her AOL account?
    </span>
    <span id="under18">
       Sorry, you're not old enough to enter 
       (and too dumb to lie about your age)
    </span>
    <span id="welcome">
       Welcome
    </span>
 </span>


Again, compile and use the module:

 use html::age_dialog;

 my $tree = html::dialog->new;

 $tree->highlander
    (age_dialog =>
     [
      under10 => sub { $_[0] < 10} , 
      under18 => sub { $_[0] < 18} ,
      welcome => sub { 1 }
     ],
     $age
    );

  print $tree->as_HTML;

  # will only output one of the 3 dialogues based on which closure 
  # fires first	


And once again, 
the function we used is the highlander method, also a part
of L<HTML::Element::Library>.


The following libraries are always available for more complicated
manipulations:

=over 

=item * L<HTML::ElementSuper>

=item * L<HTML::ElementTable>

=item * L<HTML::Element::Library>

=item * L<HTML::Element>

=item * L<HTML::Tree>

=back



=head2 Looping == child/sibling proliferation

Table unrolling, pulldown creation, C<li> unrolling, and C<dl>
unrolling are 
all examples of a tree operation in which you take a child of a node
and clone it and then alter it in some way (replace the content, alter
some of its attributes), and then stick it under its parent.

Functions for use with the common HTML elements --- C<< <table> >>, 
C<< <ol> >>,
C<< <ul> >>, C<< <dl> >>, C<< <select> >> 
are documented in 
L<HTML::Element::Library> and are
prefaced with the words "Tree Building Methods".


=head2 What Seamstress offers

Beyond the "compilation" support documented above, Seamstress offers
nothing more than a simple structure-modifying method,
expand_replace(). And to be honest, it probably shouldn't offer
that. But once, when de-Mason-izing a site, it was easier to keep
little itty-bitty components all over and so I wrote this method to
facilitate the process.

Let's say you have this HTML:

     <div id="sidebar">

	<div class="sideBlock" id=mpi>mc::picBar::index</div>

	<div class="sideBlock" id=mnm>mc::navBox::makeLinks</div>

	<div class="sideBlock" id=mg>mc::gutenBox</div>

      </div>

In this case, the content of each sideBlock is the name of a Perl
Seamstress-style class. As you know, when the constructor for such a
class is called an 
HTML::Element, C<$E>, will be returned for it's parsed content.

In this case, we want the content of the div element to go from the
being the class name to being the HTML::Element that the class
constructs. So to inline all 3 tags you would do the following;

 $tree->look_down(id => $_)->expand_replace for qw(mpi mnm mg);

=head2 What Seamstress works with

=head3 Class::Cache

Useful in mod_perl environments and anywhere you want control over the
timing of object creation.

=head3 The family of HTML::Tree contributions

=over 4

=item * L<HTML::ElementTable>

=item * L<HTML::Element::Library>

=item * L<HTML::Element>

=item * L<HTML::Tree>

=back



=head1 SEE ALSO

=head2 HTML Templating as Tree Rewriting: Part I: "If Statements"

L<http://perlmonks.org/index.pl?node_id=302606>

=head2 HTATR II: HTML table generation via DWIM tree rewriting

L<http://perlmonks.org/index.pl?node_id=303188>

=head2 Survey of Surveys on HTML Templating systems

L<http://perlmonks.org/?node_id=433729>

A fierce head-to-head between PeTaL and Seamstress goes on for several
days in this thread!


=head2 The disadvantages of mini-languages

L<http://perlmonks.org/?node_id=428053>

=head2 The limitations of mini-languages

A striking example of the limitations of mini-languages is shown here:
L<http://perlmonks.org/?node_id=493477>

But the most cogent argument for using full-strength languages as
opposed to mixing them occurs in the L<Text::Template> docs:

 When people make a template module like this one, they almost always
 start by inventing a special syntax for substitutions. For example,
 they build it so that a string like %%VAR%% is replaced with the
 value of $VAR. Then they realize the need extra formatting, so they
 put in some special syntax for formatting. Then they need a loop, so
 they invent a loop syntax. Pretty soon they have a new little
 template language. 

 This approach has two problems: First, their little language is
 crippled. If you need to do something the author hasn't thought of,
 you lose. Second: Who wants to learn another language? You already
 know Perl, so why not use it? 

=head2 Problems with JSP (JSP is similar to HTML::Mason)

L<http://www.servlets.com/soapbox/problems-jsp-reaction.html>

L<http://www-106.ibm.com/developerworks/library/w-friend.html?dwzone=web>

L<http://www.theserverside.com/resources/article.jsp?l=XMLCvsJSP>

=head2 Los Angeles Perl Mongers Talk on HTML::Seamstress

L<http://www.metaperl.com>

=head2 XMLC, A similar framework for Java

L<http://xmlc.enhydra.org>

=head2 Similar Frameworks for Perl 

Two other frameworks come to mind. Both are stricter with regard
to the correctness of the HTML and both use a different means for 
node lookup and rewrite.


=over

=item * L<Petal>

Based on Zope's TAL, this is a very nice and complete framework that is
the basis of MkDoc, a XML application server. It offers a
mini-language for XML rewriting, Seamstress does not. The philosophy
of the Seamstress is the orthogonal integration of Perl and HTML not a
mini-language and HTML.

=item * L<XML::LibXML>

By the XML guru Matt Sergeant, who is also the author of AxKit, another XML 
application server. This offers XPath for finding nodes

=item * L<XML::DOM>

If I wanted to ape XMLC entirely, I would have used TJ Mather's
L<XML::DOM>. Because XMLC is based around DOM API calls. However,
TreeBuilder is very handy and has a lot of nice libraries around it
such L<HTML::PrettyPrinter>. The biggest win of XML::DOM is it's easy
integration with L<XML::Generator>

From the docs, it looks like L<XML::GDOME> is the successor to this
module.

=back

=head1 SUPPORT

L<http://lists.sourceforge.net/lists/listinfo/seamstress-discuss>

=head1 AUTHOR

Terrence Brannon, C<< tbone@cpan.org >>

=head2 ACKNOWLEDGEMENTS

I would like to thank 

=over

=item * Chris Winters for exposing me to XMLC

=item * Paul Lucas for writing C<HTML_Tree>

L<http://homepage.mac.com/pauljlucas/software/html_tree/>

HTML_Tree is a C++ HTML manipulator with a Perl interface. Upon using
his Perl interface, I began to notice limitations and extended his
Perl interface. The author was not interested in working with me or my
extensions, so I had to continue on a separate path.

=item * C<johnnywang> for his post about dynamic HTML generation 

L<http://perlmonks.org/?node_id=505080>.

=item * Matthew Sisk and John Porter for lively personal discussions

=back


=head1 COPYRIGHT AND LICENSE

Copyright 2002-2005 by Terrence Brannon.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut
